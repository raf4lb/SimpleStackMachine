; Generates the first n fibonacci numbers
; Since max supported unsigned integer size is 16 bits, max n is 24 = 46368
; output example:
; n=24
; 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368

CONST print_n STRING "n=%u\n"

fn .main
    PUSHL_U16 2
    ALLOC_LOCAL $a    ; a
    PUSHL_U16 0
    PUSHL_U16 2
    PUSHL_U16 $a
    POP_LOCAL
    
    PUSHL_U16 2
    ALLOC_LOCAL $b    ; b
    PUSHL_U16 1
    PUSHL_U16 2
    PUSHL_U16 $b
    POP_LOCAL
    
    PUSHL_U16 2
    ALLOC_LOCAL $c    ; c
    PUSHL_U16 2
    ALLOC_LOCAL $i    ; i

    PUSHL_U16 2
    ALLOC_LOCAL $n    ; n
    PUSHL_U16 24      ; <- update n here
    PUSHL_U16 2
    PUSHL_U16 $n
    POP_LOCAL

    PUSHL_U16 2
    PUSHL_U16 $n
    PUSH_LOCAL
    PUSHL_U16 $print_n
    SYSCALL 0

    PUSHL_U16 2
    PUSHL_U16 $n
    PUSH_LOCAL
    PUSHL_U16 1
    ADD_U16
    PUSHL_U16 2
    PUSHL_U16 $n
    POP_LOCAL

    PUSHL_U16 2
    PUSHL_U16 $n
    PUSH_LOCAL
    PUSHL_U16 1
    COMPARE_GE
    POP_JUMP_IF_FALSE .false_1
    PUSHL_U16 2
    PUSHL_U16 $n
    PUSH_LOCAL
    .false_1
    PUSHL_U16 2
    PUSHL_U16 $n
    PUSH_LOCAL
    PUSHL_U16 2
    COMPARE_GE
    POP_JUMP_IF_FALSE .false_2
    PUSHL_U16 2
    PUSHL_U16 $b
    PUSH_LOCAL
    TOP_U16
    .false_2
    PUSHL_U16 3
    PUSHL_U16 2
    PUSHL_U16 $i
    POP_LOCAL

    PUSHL_U16 2
    ALLOC_LOCAL $inc ; inc
    PUSHL_U16 1
    PUSHL_U16 2
    PUSHL_U16 $inc
    POP_LOCAL
    .for
        ; for content
        PUSHL_U16 2
        PUSHL_U16 $a
        PUSH_LOCAL
        PUSHL_U16 2
        PUSHL_U16 $b
        PUSH_LOCAL
        ADD_U16
        TOP_U16
        PUSHL_U16 2
        PUSHL_U16 $c
        POP_LOCAL
        PUSHL_U16 2
        PUSHL_U16 $b
        PUSH_LOCAL
        PUSHL_U16 2
        PUSHL_U16 $a
        POP_LOCAL
        PUSHL_U16 2
        PUSHL_U16 $c
        PUSH_LOCAL
        PUSHL_U16 2
        PUSHL_U16 $b
        POP_LOCAL

        ; for increment
        PUSHL_U16 2
        PUSHL_U16 $i
        PUSHL_U16 2
        PUSH_LOCAL $i
        PUSHL_U16 2
        PUSHL_U16 $inc
        PUSH_LOCAL
        ADD_U16
        PUSHL_U16 2
        PUSHL_U16 $i
        POP_LOCAL

        ; check for condition
        PUSHL_U16 2
        PUSHL_U16 $i
        PUSH_LOCAL
        PUSHL_U16 2
        PUSHL_U16 $n
        PUSHL_U16 2
        PUSH_LOCAL $n
        COMPARE_GT
        POP_JUMP_IF_FALSE .for
        HALT
